/*
approach(value:number, target:number, delta:number):number
cycle(val:number, min:number, max:number):
//
random(x:number):
random_range(x1:number, x2:number):
irandom(x:number):
irandom_range(x1:number, x2:number):
//
abs(x:number):
round(x:number):
floor(x:number):
ceil(x:number):
sign(x:number):
frac(x:number):
sqrt(x:number):
sqr(x:number):
exp(x:number):
ln(x:number):
log2(x:number):
log10(x:number):
sin(radian_angle:number):
cos(radian_angle:number):
tan(radian_angle:number):
arcsin(x:number):
arccos(x:number):
arctan(x:number):
arctan2(y:number, x:number):
dsin(degree_angle:number):
dcos(degree_angle:number):
dtan(degree_angle:number):
darcsin(x:number):
darccos(x:number):
darctan(x:number):
darctan2(y:number, x:number):
degtorad(x:number):
radtodeg(x:number):
power(x:number, n:number):
logn(n:number, x:number):
clamp(val:number, min:number, max:number):
lerp(val1:number, val2:number, amount:number):
dot_product(x1:number, y1:number, x2:number, y2:number):
dot_product_3d(x1:number, y1:number, z1:number, x2:number, y2:number, z2:number):
dot_product_normalised(x1:number, y1:number, x2:number, y2:number):
dot_product_3d_normalised(x1:number, y1:number, z1:number, x2:number, y2:number, z2:number):
angle_difference(src:number, dest:number):
point_distance_3d(x1:number, y1:number, z1:number, x2:number, y2:number, z2:number):
point_distance(x1:number, y1:number, x2:number, y2:number):
point_direction(x1:number, y1:number, x2:number, y2:number):
lengthdir_x(len:number, dir:number):
lengthdir_y(len:number, dir:number):
*/
